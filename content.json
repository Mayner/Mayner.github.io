[{"title":"基于vue-cli脚手架搭建的单页面应用上进行的多页面应用配置","date":"2018-09-25T08:23:02.000Z","path":"20180925/基于vue-cli脚手架搭建的单页面应用上进行的多页面应用配置.html","text":"准备工作 全局安装vue-cli，并使用vue-cli快速搭建vue项目，如下： 12npm vue-cli -gvue init webpack xxx // (注释：xxx即自己的工程名称) 生成的项目目录结构如下： 1234567├─build├─config├─src│ ├─assets│ ├─components│ └─router└─static 在src目录下新建一个文件夹pages，pages目录是用来存放你的多页面应用，这里我建了三个页面应用，分别是index、goods和user，示例如下： 1234567├─assets├─components├─pages│ ├─goods│ ├─index│ └─user└─router 以上三个页面应用均由三个文件构成，分别是.html，.js和.vue文件。需要注意的一点：每个页面目录下的.html和.js的文件名应相同，且每个页面目录之间互不相同，以便于webpack编译打包时能区分开，示例如下： 12345678910111213141516├─assets├─components├─pages│ ├─goods│ │ ├─goods.index.html // 模板源文件│ │ ├─goods.index.js // 入口js文件│ │ └─Goods.vue│ ├─index│ │ ├─index.html // 模板源文件│ │ ├─index.js // 入口js文件│ │ └─App.vue│ └─user│ ├─user.index.html // 模板源文件│ ├─user.index.js // 入口js文件│ └─User.vue└─router 此处的.html文件是作为webpack打包的模板html源文件，该文件的内容与工程根目录vue-multipage-config下的index.html相同，可以直接拷贝；而.js则是打包的入口js文件，亦直接拷贝src目录下的main.js文件的内容，别忘了将vue实例里的template的值改为对应的模块文件，这里选goods.index.js举例，示例如下： 123456789101112// goods.index.js文件import Vue from &apos;vue&apos;import Goods from &apos;./Goods&apos; // 进入Goods.vue...new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; Goods &#125;, // 注册Goods组件 template: &apos;&lt;Goods/&gt;&apos; // 改成&lt;Goods/&gt;&#125;) 以上准备工作做好，接下来是如何进行多页面应用的配置。 webpack配置 在package.json文件的devDependencies中添加&quot;glob&quot;: &quot;^7.1.3&quot;这个第三方依赖。 以下直接贴出需要改动的四个配置文件，里面修改或添加的地方均已写注释。 utils.js文件的修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&apos;use strict&apos;const path = require(&apos;path&apos;)const config = require(&apos;../config&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const packageConfig = require(&apos;../package.json&apos;)/* 此处添加引进三个模块=================开始================= */// 1、glob模块允许你使用 *等符号, 例如lib/*.js就是获取lib文件夹下的所有js后缀名的文件const glob = require(&apos;glob&apos;)// 2、html-webpack-plugin模块根据页面模板生成htmlconst HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)// 3、webpack-merge模块用于做相应的合并处理const merge = require(&apos;webpack-merge&apos;)/* 此处添加引进三个模块=================结束================= */exports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125;exports.cssLoaders = function (options) &#123; options = options || &#123;&#125; const cssLoader = &#123; loader: &apos;css-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; const postcssLoader = &#123; loader: &apos;postcss-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; // generate loader string to be used with extract text plugin function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] if (loader) &#123; loaders.push(&#123; loader: loader + &apos;-loader&apos;, options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; // Extract CSS when that option is specified // (which is the case during production build) if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &apos;vue-style-loader&apos; &#125;) &#125; else &#123; return [&apos;vue-style-loader&apos;].concat(loaders) &#125; &#125; // https://vue-loader.vuejs.org/en/configurations/extract-css.html return &#123; css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders(&apos;less&apos;), sass: generateLoaders(&apos;sass&apos;, &#123; indentedSyntax: true &#125;), scss: generateLoaders(&apos;sass&apos;), stylus: generateLoaders(&apos;stylus&apos;), styl: generateLoaders(&apos;stylus&apos;) &#125;&#125;// Generate loaders for standalone style files (outside of .vue)exports.styleLoaders = function (options) &#123; const output = [] const loaders = exports.cssLoaders(options) for (const extension in loaders) &#123; const loader = loaders[extension] output.push(&#123; test: new RegExp(&apos;\\\\.&apos; + extension + &apos;$&apos;), use: loader &#125;) &#125; return output&#125;/* 此处是添加多页面配置的部分=================开始================= */// 取得多页面项目的根目录，一般放在src文件夹下的pages文件夹const PAGE_PATH = path.join(__dirname, &apos;..&apos;, &apos;src/pages&apos;)// 多入口js配置exports.entries = function () &#123; // 通过glob模块读取pages文件夹下的所有对应文件夹下的js后缀文件，如果该文件存在，那么就作为入口处理 let entryFiles = glob.sync(PAGE_PATH + &apos;/*/*.js&apos;) let entriesObj = &#123;&#125; entryFiles.forEach(filePath =&gt; &#123; let filename = filePath.substring(filePath.lastIndexOf(&apos;\\/&apos;) + 1, filePath.lastIndexOf(&apos;.&apos;)) entriesObj[filename] = filePath &#125;) return entriesObj&#125;// 多页面输出配置exports.htmlPlugins = function () &#123; // 与上面的多页面入口配置相同，读取pages文件夹下的对应的html后缀文件，然后放入数组中 let entryHtml = glob.sync(PAGE_PATH + &apos;/*/*.html&apos;) let arr = [] entryHtml.forEach(filePath =&gt; &#123; let filename = filePath.substring(filePath.lastIndexOf(&apos;\\/&apos;) + 1, filePath.lastIndexOf(&apos;.&apos;)) let conf = &#123; // 产出到dist目录下的入口html的文件名 filename: filename + &apos;.html&apos;, // 多页面入口html模板来源 template: filePath, inject: true, // 页面模板需要加对应的js脚本，如果不加chunks这句代码则每个页面都会引入所有的js脚本 // 此处的filename必须跟上面的多页面入口配置entries里的filename相一致， // 即pages文件夹里各个模块的入口html模板和js的文件名必须相同 chunks: [&apos;manifest&apos;, &apos;vendor&apos;, filename] &#125; if (process.env.NODE_ENV === &apos;production&apos;) &#123; conf = merge(conf, &#123; minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: &apos;dependency&apos; &#125;) &#125; arr.push(new HtmlWebpackPlugin(conf)) &#125;) return arr&#125;/* 此处是添加多页面配置的部分=================结束================= */exports.createNotifierCallback = () =&gt; &#123; const notifier = require(&apos;node-notifier&apos;) return (severity, errors) =&gt; &#123; if (severity !== &apos;error&apos;) return const error = errors[0] const filename = error.file &amp;&amp; error.file.split(&apos;!&apos;).pop() notifier.notify(&#123; title: packageConfig.name, message: severity + &apos;: &apos; + error.name, subtitle: filename || &apos;&apos;, icon: path.join(__dirname, &apos;logo.png&apos;) &#125;) &#125;&#125; webpack.base.conf.js文件的修改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&apos;use strict&apos;const path = require(&apos;path&apos;)const utils = require(&apos;./utils&apos;)const config = require(&apos;../config&apos;)const vueLoaderConfig = require(&apos;./vue-loader.conf&apos;)function resolve (dir) &#123; return path.join(__dirname, &apos;..&apos;, dir)&#125;const createLintingRule = () =&gt; (&#123; test: /\\.(js|vue)$/, loader: &apos;eslint-loader&apos;, enforce: &apos;pre&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)], options: &#123; formatter: require(&apos;eslint-friendly-formatter&apos;), emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125;)module.exports = &#123; context: path.resolve(__dirname, &apos;../&apos;), /* 此处由单入口修改为多入口=================开始================= */ entry: utils.entries(), /* 此处由单入口修改为多入口=================结束================= */ output: &#123; path: config.build.assetsRoot, filename: &apos;[name].js&apos;, // 此处的name取的就是entry对象里面的key名 publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125; &#125;, module: &#123; rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), &#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: vueLoaderConfig &#125;, &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)] &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) &#125; &#125; ] &#125;, node: &#123; // prevent webpack from injecting useless setImmediate polyfill because Vue // source contains it (although only uses it if it&apos;s native). setImmediate: false, // prevent webpack from injecting mocks to Node native modules // that does not make sense for the client dgram: &apos;empty&apos;, fs: &apos;empty&apos;, net: &apos;empty&apos;, tls: &apos;empty&apos;, child_process: &apos;empty&apos; &#125;&#125; webpack.dev.conf.js的修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&apos;use strict&apos;const utils = require(&apos;./utils&apos;)const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;)const merge = require(&apos;webpack-merge&apos;)const path = require(&apos;path&apos;)const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)// const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) // 因为已将该模块提取到utils中使用，故此处不再需要const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;)const portfinder = require(&apos;portfinder&apos;)const HOST = process.env.HOSTconst PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)const devWebpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, // cheap-module-eval-source-map is faster for development devtool: config.dev.devtool, // these devServer options should be customized in /config/index.js devServer: &#123; clientLogLevel: &apos;warning&apos;, historyApiFallback: &#123; rewrites: [ &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &apos;index.html&apos;) &#125;, ], &#125;, hot: true, contentBase: false, // since we use CopyWebpackPlugin. compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125; &#125;, plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env&apos;: require(&apos;../config/dev.env&apos;) &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update. new webpack.NoEmitOnErrorsPlugin(), // https://github.com/ampedandwired/html-webpack-plugin /* 将此处注释掉=================开始================= */ // new HtmlWebpackPlugin(&#123; // filename: &apos;index.html&apos;, // template: &apos;index.html&apos;, // inject: true // &#125;), /* 将此处注释掉=================结束================= */ // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &apos;../static&apos;), to: config.dev.assetsSubDirectory, ignore: [&apos;.*&apos;] &#125; ]) ].concat(utils.htmlPlugins()) // 将utils中定义的多页面输出配置在此处用concat连接起来&#125;)module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // publish the new Port, necessary for e2e tests process.env.PORT = port // add port to devServer config devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) webpack.prod.conf.js的修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&apos;use strict&apos;const path = require(&apos;path&apos;)const utils = require(&apos;./utils&apos;)const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;)const merge = require(&apos;webpack-merge&apos;)const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)// const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) // 因为已将该模块提取到utils中使用，故此处不再需要const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const OptimizeCSSPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)const env = require(&apos;../config/prod.env&apos;)const webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true &#125;) &#125;, devtool: config.build.productionSourceMap ? config.build.devtool : false, output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;) &#125;, plugins: [ // http://vuejs.github.io/vue-loader/en/workflow/production.html new webpack.DefinePlugin(&#123; &apos;process.env&apos;: env &#125;), new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), // extract css into its own file new ExtractTextPlugin(&#123; filename: utils.assetsPath(&apos;css/[name].[contenthash].css&apos;), // Setting the following option to `false` will not extract CSS from codesplit chunks. // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack. // It&apos;s currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it&apos;s `false`, // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110 allChunks: true, &#125;), // Compress extracted CSS. We are using this plugin so that possible // duplicated CSS from different components can be deduped. new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), // generate dist index.html with correct asset hash for caching. // you can customize output by editing /index.html // see https://github.com/ampedandwired/html-webpack-plugin /* 将此处注释掉=================开始================= */ // new HtmlWebpackPlugin(&#123; // filename: config.build.index, // template: &apos;index.html&apos;, // inject: true, // minify: &#123; // removeComments: true, // collapseWhitespace: true, // removeAttributeQuotes: true // // more options: // // https://github.com/kangax/html-minifier#options-quick-reference // &#125;, // // necessary to consistently work with multiple chunks via CommonsChunkPlugin // chunksSortMode: &apos;dependency&apos; // &#125;), /* 将此处注释掉=================结束================= */ // keep module.id stable when vendor modules does not change new webpack.HashedModuleIdsPlugin(), // enable scope hoisting new webpack.optimize.ModuleConcatenationPlugin(), // split vendor js into its own file new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks (module) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ) &#125; &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos;, minChunks: Infinity &#125;), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;app&apos;, async: &apos;vendor-async&apos;, children: true, minChunks: 3 &#125;), // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &apos;../static&apos;), to: config.build.assetsSubDirectory, ignore: [&apos;.*&apos;] &#125; ]) ].concat(utils.htmlPlugins()) // 将utils中定义的多页面输出配置在此处用concat连接起来&#125;)if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;) webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: &apos;[path].gz[query]&apos;, algorithm: &apos;gzip&apos;, test: new RegExp( &apos;\\\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;)$&apos; ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;if (config.build.bundleAnalyzerReport) &#123; const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;module.exports = webpackConfig 运行项目分别对每个.html模板文件添加a标签进行跳转到另外两个页面，示例如下：123456&lt;!-- index.html文件 --&gt;...&lt;a href=&quot;user.index.html&quot;&gt;跳转到用户主页&lt;/a&gt;&lt;a href=&quot;goods.index.html&quot;&gt;跳转到商品主页&lt;/a&gt;... 123456&lt;!-- goods.index.html文件 --&gt;...&lt;a href=&quot;index.html&quot;&gt;跳转到首页&lt;/a&gt;&lt;a href=&quot;user.index.html&quot;&gt;跳转到用户主页&lt;/a&gt;... 123456&lt;!-- user.index.html文件 --&gt;...&lt;a href=&quot;index.html&quot;&gt;跳转到首页&lt;/a&gt;&lt;a href=&quot;goods.index.html&quot;&gt;跳转到商品主页&lt;/a&gt;... 开发环境运行12345678910111213141516# 进入vue-multipage-config目录cd vue-multipage-config# 安装所有依赖npm install# 开发环境启动项目,浏览器访问http://localhost:8080/# 默认访问的是目录/src/pages/index/下的index.html这个文件npm run dev# 现在可以通过页面的点击按钮跳转到其它页面，注意观察跳转后的url地址# 比如跳转到商品主页，url地址变成了http://localhost:8080/goods.index.html#/# 而不是http://localhost:8080/#/goods.index.html# 因此，若手动输入url地址访问时需注意正确书写页面地址：# http://localhost:8080/goods.index.html#/ 生产环境运行123456# 开发完成后执行打包命令，会在根目录生成dist文件夹npm run build# dist目录下的三个html文件便是webpack根据我们的配置生成的入口html文件# 不要在本地打开访问，请使用服务端访问文件","tags":[{"name":"vue","slug":"vue","permalink":"https://mayner.github.io/tags/vue/"},{"name":"vue-multipage","slug":"vue-multipage","permalink":"https://mayner.github.io/tags/vue-multipage/"},{"name":"webpack","slug":"webpack","permalink":"https://mayner.github.io/tags/webpack/"}]},{"title":"nvm安装总结","date":"2018-04-20T10:11:27.000Z","path":"20180420/nvm-install.html","text":"一直以来都在用 nvm 来管理我的 node 的版本，然而，最近在尝试入坑快应用时，使用 npm install -g hap-toolkit 安装快应用脚手架，接着查看版本号检测是否安装成功，输入 hap -V ，结果显示： &#39;hap&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件。但进到 hap-toolkit 目录下运行 hap -V ，结果正常，想着应该是环境变量没配好，就试了一下安装别的工具，果然也出现同样的问题，捣鼓了一番环境变量，还是不行。最后决定卸载nvm重新安装，于是便开始了 nvm 的安装填坑之路。此文旨在记录本人安装 nvm 的过程以及在安装过程中遇到的一点小问题。 nvm的作用nvm 是 node 的版本管理工具，它能帮助你快速安装并切换使用node的版本，为什么要切换node的版本？因为各种工具使用的 node 版本可能不一致，就会出现一些奇怪的问题。比如：快应用，就需要安装6.0以上版本，官方推荐使用的是 node v6.11.3，还强调不要使用8.0.*版本，因为这个版本内部 ZipStream 实现与 node-archive 包不兼容，会引起报错。也就是说，我们在平常工作中经常会碰到使用不同 node 版本，而每次切换版本挺麻烦还耗时，你要先卸载掉当前已经安装使用的 node 版本，然后重新下载安装需要的那个版本，这个过程是繁琐的；而且为了某些功能而去反复卸载下载安装不同的 node 版本，这是非常不划算的，nvm 就是专门解决这个问题的工具。 nvm的下载安装1.下载地址：nvm的下载地址（如果你已经单独安装了node，建议先卸载）。2.我选择的是1.1.5版本里 nvm-setup.zip 这个安装包。3.解压后双击安装，此处注意以下两点： 在选择安装目录这一步的时候我选的是默认路径，记住这一步骤的路径，因为之后使用nvm安装的 node 版本都会存放在该目录下，安装完后里面有个 settings.txt 文件，之后配置环境变量的时候有用。 接着到 Set Node.js Symlink 这一步，这里的目录是之后 nvm use 你使用的那个 node 版本程序的存放目录。我这里选的是 C:\\dev\\nodejs 。其他步骤都按默认的走，一路next直到安装完成。 4.打开命令行窗口1234nvm v // 查看nvm版本 1.1.5nvm install latest // 下载node最新版 v9.11.1nvm install 8.11.1 // 下载node稳定版 v8.11.1nvm install 6.11.3 // 下载指定版本 下载对应的 node 版本后会在 nvm 的安装目录下生成对应的版本文件夹（即上述所说的 C:\\Users\\ab052479\\AppData\\Roaming\\nvm），在命令行输入 nvm list 可以看到下载的 node 版本及当前使用的版本是 6.11.3 ，再输入 nvm use 8.11.1 切换使用 node v8.11.1 版本，此时再 nvm list 可以看到当前使用的版本已经变成 8.11.1 。这时就会在 C:\\dev 的目录出现个 nodejs 文件夹的快捷方式。 npm的全局安装路径配置执行命令: npm config set prefix &quot;C:\\dev\\node\\npm-global&quot; C:\\Users\\你的用户名\\ 会生成个 .npmrc 文件，内容如下：prefix=C:\\dev\\node\\npm-global这时候再去安装全局的东西，比如 npm install -g hap-toolkit ，所有全局的包都会出现在 C:\\dev\\node\\npm-global\\node_modules 目录中。 环境变量的配置打开环境变量配置窗口的路径：此电脑右键 → 属性 → 高级系统设置 → 环境变量。 用户变量NVM_HOME 的值设成 C:\\dev\\node\\npm-global ， NVM_SYMLINK 的值设成 C:\\dev\\nodejs, path 需要有 %NVM_HOME% 和 %NVM_SYMLINK% 。 系统变量NVM_HOME 的值设成 C:\\dev\\node\\npm-global ， NVM_SYMLINK 的值设成 C:\\dev\\nodejs, path 需要有 %NVM_HOME% 和 %NVM_SYMLINK% 。在 path的最后再配上一条 C:\\Users\\ab052479\\AppData\\Roaming\\nvm ，这样就可以全局使用 nvm 了。然而，当我在D盘某个项目里打开命令行使用 nvm 操作时，报错了：ERROR open C:\\dev\\node\\npm-global\\settings.txt: The system cannot find the file specified.不过别慌，人家已经给你报出是什么原因了：该路径下找不到 settings.txt 这个文件。这时，你只需要去 nvm 的安装路径 C:\\Users\\ab052479\\AppData\\Roaming\\nvm 下把 settings.txt 文件复制到 C:\\dev\\node\\npm-global 就行了（记得关掉命令行窗口重新开一个再试）。","tags":[{"name":"nvm","slug":"nvm","permalink":"https://mayner.github.io/tags/nvm/"},{"name":"win10","slug":"win10","permalink":"https://mayner.github.io/tags/win10/"},{"name":"node.js","slug":"node-js","permalink":"https://mayner.github.io/tags/node-js/"}]}]